<!DOCTYPE html>
<html>
<head>
  <title>Test 22x Pattern</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
      background: #f0f0f0;
    }
    #controls {
      margin-bottom: 20px;
    }
    button {
      padding: 10px 20px;
      margin-right: 10px;
      cursor: pointer;
    }
    #info {
      margin-top: 10px;
      padding: 10px;
      background: white;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <button onclick="generateNew()">Generate New Pattern</button>
    <button onclick="toggleGuides()">Toggle Symmetry Guides</button>
    <label>
      <input type="checkbox" id="showGrid" onchange="redraw()"> Show Grid
    </label>
  </div>
  <div id="info">
    <h3>22x (pgg) Pattern - Glide Reflections</h3>
    <p><strong>Operations:</strong><br>
    1. Original motif<br>
    2. Horizontal glide: shift right by a/2, reflect vertically<br>
    3. Vertical glide: shift up by b/2, reflect horizontally<br>
    4. Double glide: both operations (= 180Â° rotation)<br>
    <br>
    These create 4 rotation centers at (0,0), (a/2,0), (0,b/2), (a/2,b/2)</p>
  </div>
  
  <script src="genome.js"></script>
  <script src="pattern.js"></script>
  
  <script>
    let showSymmetryGuides = false;
    let testGenome;
    let canvas;
    
    // Color palettes
    const palettes = {
      sunset: ["#FF6B6B", "#FFA06B", "#FFD06B", "#FF8FA3"],
      ocean: ["#023E8A", "#0077B6", "#00B4D8", "#90E0EF"],
      forest: ["#2D6A4F", "#52B788", "#95D5B2", "#B7E4C7"],
      mono: ["#212529", "#495057", "#868E96", "#DEE2E6"],
    };
    
    function setup() {
      canvas = createCanvas(800, 600);
      canvas.parent(document.body);
      generateNew();
    }
    
    function draw() {
      background(255);
      
      if (document.getElementById('showGrid').checked) {
        drawGrid();
      }
      
      push();
      translate(width/2, height/2);
      drawWallpaperOn(window, testGenome);
      pop();
      
      if (showSymmetryGuides) {
        drawRotationCenters();
      }
    }
    
    function drawGrid() {
      stroke(200);
      strokeWeight(0.5);
      const gridSize = testGenome.motifScale;
      
      for (let x = 0; x < width; x += gridSize) {
        line(x, 0, x, height);
      }
      for (let y = 0; y < height; y += gridSize) {
        line(0, y, width, y);
      }
    }
    
    function drawRotationCenters() {
      const a = testGenome.motifScale;
      const spec = getGroupSpec("22x");
      const tileRange = 4;
      const L = 2000;
      
      push();
      translate(width/2, height/2);
      
      // Draw glide axes (the defining feature of pgg)
      strokeWeight(2);
      
      // Horizontal glide axes at y = 0 and y = 0.5
      stroke(255, 0, 160, 160); // Magenta for horizontal glides
      for (let i = -tileRange; i <= tileRange; i++) {
        for (let j = -tileRange; j <= tileRange; j++) {
          const p = latticePointFrom(spec, a, i, j);
          // Glide at y = 0
          line(p.x - L, p.y, p.x + L, p.y);
          // Glide at y = 0.5
          line(p.x - L, p.y + a/2, p.x + L, p.y + a/2);
        }
      }
      
      // Vertical glide axes at x = 0 and x = 0.5
      stroke(0, 255, 160, 160); // Cyan for vertical glides
      for (let i = -tileRange; i <= tileRange; i++) {
        for (let j = -tileRange; j <= tileRange; j++) {
          const p = latticePointFrom(spec, a, i, j);
          // Glide at x = 0
          line(p.x, p.y - L, p.x, p.y + L);
          // Glide at x = 0.5
          line(p.x + a/2, p.y - L, p.x + a/2, p.y + L);
        }
      }
      
      // Draw the 4 rotation centers that result from glide intersections
      noStroke();
      fill(255, 200, 0, 100); // Orange for rotation centers
      for (let i = -tileRange; i <= tileRange; i++) {
        for (let j = -tileRange; j <= tileRange; j++) {
          const p = latticePointFrom(spec, a, i, j);
          // Centers at (0,0), (a/2,0), (0,a/2), (a/2,a/2)
          ellipse(p.x, p.y, 10, 10);
          ellipse(p.x + a/2, p.y, 10, 10);
          ellipse(p.x, p.y + a/2, 10, 10);
          ellipse(p.x + a/2, p.y + a/2, 10, 10);
        }
      }
      
      pop();
    }
    
    function generateNew() {
      testGenome = {
        group: "22x",
        palette: random(Object.keys(palettes)),
        motifScale: 80,
        rotation: random(TWO_PI),
        hueShift: random(-20, 20),
        overlapMode: random(["overlap", "touch", "space"]),
        shapeStyle: random(["curved", "straight", "mixed"]),
        numShapes: floor(random(3, 6)),
        shapes: []
      };
      
      // Generate random shapes
      for (let i = 0; i < testGenome.numShapes; i++) {
        const shapeTypes = testGenome.shapeStyle === "curved" ? CURVED_SHAPES :
                          testGenome.shapeStyle === "straight" ? STRAIGHT_SHAPES :
                          CURVED_SHAPES.concat(STRAIGHT_SHAPES);
        testGenome.shapes.push({
          type: random(shapeTypes),
          curveBias: random(0.2, 0.8),
          fatness: random(0.5, 1.5),
          radiusJitter: random(-0.1, 0.1),
          angleJitter: random(-0.2, 0.2),
          sizeJitter: random(-0.2, 0.2)
        });
      }
      
      redraw();
    }
    
    function toggleGuides() {
      showSymmetryGuides = !showSymmetryGuides;
      redraw();
    }
    
    function ensureGenomeColors(g) {
      return g;
    }
    
    function genomeHash(g) {
      // Simple hash for testing
      return floor(random(100000));
    }
  </script>
</body>
</html>
