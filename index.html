<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Orbifolder - Pattern Evolution</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #1a1a1a;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: Arial, sans-serif;
      overflow: hidden;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }
    
    #canvas-container {
      position: relative;
      cursor: default;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: manipulation;
    }

    canvas {
      display: block;
      max-width: 100%;
      max-height: 100%;
    }
    
    #group-label {
      position: absolute;
      top: 24px;
      left: 50%;
      transform: translate(-50%, 0);
      font-size: 48px;
      font-weight: 700;
      color: #ffffff;
      background: rgba(0, 0, 0, 0.78);
      padding: 0 16px;
      border-radius: 6px;
      border: 2px solid rgba(255, 255, 255, 0.85);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
      opacity: 0;
      transition: opacity 0.25s ease-in-out;
      pointer-events: none;
      z-index: 10;
      max-width: calc(100% - 48px);
      text-align: center;
      white-space: nowrap;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 56px;
      min-width: 56px;
    }
    #next-button {
      position: absolute;
      right: 24px;
      top: 24px;
      font-size: 32px;
      font-weight: 700;
      color: #ffffff;
      background: rgba(0, 0, 0, 0.78);
      border-radius: 6px;
      border: 2px solid rgba(255, 255, 255, 0.85);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
      opacity: 0;
      transition: opacity 0.2s ease-in-out;
      pointer-events: none;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 56px;
      height: 56px;
      cursor: pointer;
      transform-origin: center;
    }
    #next-button.visible { opacity: 1; pointer-events: auto; }

    #state-button {
      position: absolute;
      left: 24px;
      top: 24px;
      font-size: 32px;
      font-weight: 700;
      color: #ffffff;
      background: rgba(0, 0, 0, 0.78);
      border-radius: 6px;
      border: 2px solid rgba(255, 255, 255, 0.85);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
      opacity: 0;
      transition: opacity 0.2s ease-in-out;
      pointer-events: none;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 56px;
      height: 56px;
      cursor: pointer;
    }
    #state-button.visible { opacity: 1; pointer-events: auto; }
    #state-button.state-back {
      transform: scaleX(-1);
    }
    
    #group-label.visible {
      opacity: 1;
    }
    /* Orbifold coloring */
    #group-label .orb-blue { color: #66a7ff; }
    #group-label .orb-red  { color: #ff4d4d; }
    
    @media (max-height: 600px) {
      #group-label {
        font-size: 42px;
      }
    }

    @media (max-width: 480px) {
      #group-label {
        font-size: 36px;
      }
    }
  </style>
</head>
<body>
  <div id="canvas-container">
    <div id="group-label"></div>
    <div id="state-button" aria-label="Help">?</div>
    <div id="next-button" aria-label="Next pattern">➜</div>
  </div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <script src="wallpaper_groups.js"></script>
  <script src="wallpaper_math.js"></script>
  <script src="wallpaper_guides.js"></script>
  <script src="pattern.js"></script>
  <script src="genome.js"></script>
  
  <script>
    const targetAspect = 4 / 6; // width / height (portrait bias) .
    const PATTERN_REPEATS_X = 3;
    const PATTERN_REPEATS_Y = 6;

    let palettes = {
      warm: ["#e63946", "#f1faee", "#a8dadc", "#ffbe0b", "#fb5607"],
      cool: ["#457b9d", "#1d3557", "#a8dadc", "#118ab2", "#06d6a0"],
      earth: ["#2a9d8f", "#e9c46a", "#f4a261", "#264653", "#dda15e"],
      vivid: ["#ffb703", "#fb8500", "#023047", "#8ecae6", "#219ebc"],
    };

    let baseGenome = null;
    let currentGenome = null;
    let state = "pattern"; // 'pattern' or 'showing-group'

    let containerEl;
    let groupLabelEl;
    let stateButtonEl;
    let nextButtonEl;
    let canvas;
    let pg;

    let showSymmetryGuides = false;
    let lastDevicePixelRatio = Math.max(0.1, window.devicePixelRatio || 1);
    let lastZoomScale = window.visualViewport ? window.visualViewport.scale : 1;

    function cloneGenome(g) {
      return JSON.parse(JSON.stringify(g));
    }

    function checkForZoomChange() {
      const currentRatio = Math.max(0.1, window.devicePixelRatio || 1);
      const currentZoomScale = window.visualViewport ? window.visualViewport.scale : 1;
      
      const ratioChanged = Math.abs(currentRatio - lastDevicePixelRatio) > 0.01;
      const zoomChanged = Math.abs(currentZoomScale - lastZoomScale) > 0.01;
      
      if (ratioChanged || zoomChanged) {
        console.log('Zoom detected! Scale:', currentZoomScale, 'DPR:', currentRatio);
        lastDevicePixelRatio = currentRatio;
        lastZoomScale = currentZoomScale;
        pixelDensity(currentRatio);
        if (!pg) {
          pg = createGraphics(width, height);
        }
        if (pg.pixelDensity) pg.pixelDensity(currentRatio);
        if (baseGenome && currentGenome) {
          updateCurrentGenomeScale();
          renderPattern();
          drawScreen();
        }
      }
    }

    function computeViewportRect() {
      const vv = window.visualViewport;
      const vw = Math.max(1, Math.round((vv && vv.width) ? vv.width : (window.innerWidth || width)));
      const vh = Math.max(1, Math.round((vv && vv.height) ? vv.height : (window.innerHeight || height)));
      return {
        width: vw,
        height: vh,
      };
    }

    function applyContainerSize() {
      const rect = computeViewportRect();
      if (containerEl) {
        containerEl.style.width = `${rect.width}px`;
        containerEl.style.height = `${rect.height}px`;
      }
      return rect;
    }

    function setup() {
      containerEl = document.getElementById("canvas-container");
      groupLabelEl = document.getElementById("group-label");
      stateButtonEl = document.getElementById("state-button");
      nextButtonEl = document.getElementById("next-button");

      const { width: w, height: h } = applyContainerSize();
      lastDevicePixelRatio = Math.max(0.1, window.devicePixelRatio || 1);
      lastZoomScale = window.visualViewport ? window.visualViewport.scale : 1;

      canvas = createCanvas(w, h);
      canvas.parent(containerEl);
      pixelDensity(lastDevicePixelRatio);
      angleMode(RADIANS);
      noLoop();

      pg = createGraphics(w, h);
      if (pg.pixelDensity) pg.pixelDensity(lastDevicePixelRatio);

      generateNewPattern();
      drawScreen();

      // Poll for zoom changes every 250ms
      setInterval(checkForZoomChange, 250);

      if (stateButtonEl) {
        stateButtonEl.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (state === "pattern") {
            state = "guides";
          } else if (state === "guides") {
            state = "showing-group";
          } else {
            state = "pattern";
          }
          renderPattern();
          drawScreen();
        });
      }

      if (nextButtonEl) {
        nextButtonEl.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          generateNewPattern();
        });
      }
    }

    function draw() {
      // Rendering is event-driven via drawScreen()
    }

    function updateCurrentGenomeScale() {
      if (!baseGenome) return;
      const rect = computeViewportRect();
      
      // Try multiple methods for zoom detection
      let zoomFactor = 1;
      
      // Method 1: visualViewport.scale (best if available)
      if (window.visualViewport && typeof window.visualViewport.scale === 'number' && window.visualViewport.scale !== 1) {
        const currentZoomScale = window.visualViewport.scale;
        const initialZoomScale = baseGenome.initialZoomScale || 1;
        zoomFactor = currentZoomScale / initialZoomScale;
      }
      // Method 2: Use viewport size changes as proxy for zoom
      else if (baseGenome.initialViewportWidth) {
        const widthRatio = baseGenome.initialViewportWidth / rect.width;
        const heightRatio = baseGenome.initialViewportHeight / rect.height;
        // Use the average of width and height ratios for zoom detection
        zoomFactor = (widthRatio + heightRatio) / 2;
      }
      
      if (!baseGenome.seedMotifScale) baseGenome.seedMotifScale = baseGenome.motifScale;
      const baseCell = estimateCellSize(baseGenome);
      const safeCellW = Math.max(1, baseCell.w);
      const safeCellH = Math.max(1, baseCell.h);
      const horizontalSpan = safeCellW * PATTERN_REPEATS_X;
      const minimumVerticalSpan = 2 * horizontalSpan;
      const configuredVerticalSpan = safeCellH * PATTERN_REPEATS_Y;
      const verticalSpanForViewport = horizontalSpan * (rect.height / Math.max(1, rect.width));
      const verticalSpan = Math.max(
        minimumVerticalSpan,
        configuredVerticalSpan,
        verticalSpanForViewport
      );
      let scaleFactor = Math.min(
        rect.width / horizontalSpan,
        rect.height / verticalSpan
      );
      if (!Number.isFinite(scaleFactor) || scaleFactor <= 0) {
        scaleFactor = 1;
      }
      const scaledGenome = cloneGenome(baseGenome);
      const baseScale = baseGenome.seedMotifScale || baseGenome.motifScale || 1;
      // Apply zoom factor just like in the test (latticeScale * zoomScale)
      scaledGenome.motifScale = baseScale * scaleFactor * zoomFactor;
      scaledGenome.seedMotifScale = baseScale;
      currentGenome = scaledGenome;
      
      // Debug logging
      console.log('Zoom update:', {
        hasVisualViewport: !!window.visualViewport,
        visualViewportScale: window.visualViewport?.scale,
        currentWidth: rect.width,
        currentHeight: rect.height,
        initialWidth: baseGenome.initialViewportWidth,
        initialHeight: baseGenome.initialViewportHeight,
        zoomFactor,
        baseScale,
        scaleFactor,
        finalMotifScale: scaledGenome.motifScale,
        devicePixelRatio: window.devicePixelRatio
      });
    }

    function renderPattern() {
      if (!currentGenome) return;
      const rect = computeViewportRect();
      const currentRatio = Math.max(0.1, lastDevicePixelRatio);
      if (!pg) {
        pg = createGraphics(rect.width, rect.height);
        if (pg.pixelDensity) pg.pixelDensity(currentRatio);
      }
      if (pg.width !== rect.width || pg.height !== rect.height) {
        pg.resizeCanvas(rect.width, rect.height);
        if (pg.pixelDensity) pg.pixelDensity(currentRatio);
      }
      pg.background(20);
      pg.push();
      pg.translate(pg.width / 2, pg.height / 2);
      const prevShowGuides = showSymmetryGuides;
      showSymmetryGuides = (state === "guides" || state === "showing-group");
      drawWallpaperOn(pg, currentGenome);
      showSymmetryGuides = prevShowGuides;
      pg.pop();
    }

    function drawScreen() {
      background(20);
      if (currentGenome && pg) {
        image(pg, 0, 0, width, height);
      }
      // Always show the state and next buttons
      if (stateButtonEl) {
        stateButtonEl.classList.remove('state-back');
        if (state === "pattern") {
          stateButtonEl.textContent = "?";
        } else if (state === "guides") {
          stateButtonEl.textContent = "??";
        } else {
          stateButtonEl.textContent = "➜";
          stateButtonEl.classList.add('state-back');
        }
        stateButtonEl.classList.add('visible');
      }
      if (nextButtonEl) {
        nextButtonEl.classList.add('visible');
      }
      // Group label visibility only in showing-group
      if (groupLabelEl) {
        if (state === "showing-group" && currentGenome) {
          groupLabelEl.innerHTML = colorOrbifold(currentGenome.group);
          groupLabelEl.classList.add("visible");
        } else {
          groupLabelEl.classList.remove("visible");
        }
      }
    }

    function colorOrbifold(sig) {
      const s = String(sig || "");
      let out = "";
      let afterStar = false;
      for (const ch of s) {
        const isDigit = ch >= '0' && ch <= '9';
        const isRed = (ch === '*') || (ch === 'x') || (afterStar && isDigit);
        out += `<span class="${isRed ? 'orb-red' : 'orb-blue'}">${ch}</span>`;
        if (ch === '*') afterStar = true;
      }
      return out;
    }

    function generateNewPattern() {
      baseGenome = randomGenome();
      baseGenome.seedMotifScale = baseGenome.motifScale;
      
      // Store initial zoom scale from visualViewport
      baseGenome.initialZoomScale = window.visualViewport ? window.visualViewport.scale : 1;
      
      // Store initial viewport dimensions for fallback zoom detection
      const initialRect = computeViewportRect();
      baseGenome.initialViewportWidth = initialRect.width;
      baseGenome.initialViewportHeight = initialRect.height;
      
      state = "pattern";
      updateCurrentGenomeScale();
      renderPattern();
      drawScreen();
    }

    // Disable general click/touch interactions; only buttons trigger actions

    function windowResized() {
      const { width: w, height: h } = applyContainerSize();
      const currentRatio = Math.max(0.1, window.devicePixelRatio || 1);
      lastDevicePixelRatio = currentRatio;
      lastZoomScale = window.visualViewport ? window.visualViewport.scale : 1;
      resizeCanvas(w, h);
      pixelDensity(currentRatio);
      if (pg) {
        pg.resizeCanvas(w, h);
        if (pg.pixelDensity) pg.pixelDensity(currentRatio);
      } else {
        pg = createGraphics(w, h);
        if (pg.pixelDensity) pg.pixelDensity(currentRatio);
      }
      updateCurrentGenomeScale();
      renderPattern();
      drawScreen();
    }
  </script>
</body>
</html>
